// Generated by CoffeeScript 1.10.0
(function() {
  var Promise, _, di, express, get, tFlow, xml;

  express = require('express');

  tFlow = require('./voice-call');

  Promise = require('bluebird');

  xml = require('xml');

  _ = require('lodash');

  di = require('./../di');

  get = function(req, value) {
    var ref, ref1;
    if (((ref = req.body) != null ? ref[value] : void 0) != null) {
      return req.body[value];
    }
    if (((ref1 = req.query) != null ? ref1[value] : void 0) != null) {
      return req.query[value];
    }
  };

  module.exports = function() {
    var app;
    app = {
      calls: {},
      scripts: {},
      voice: 'male',
      log: function(call) {
        console.log(call.body);
        if (call.digits) {
          return console.log("Input: " + call.digits);
        }
      },
      onError: function(call, error) {
        var flow;
        console.log(error);
        flow = call.flow;
        flow.clear();
        flow.say('We are sorry, an error has occurred. This call will now be disconnected.');
        return flow.hangup();
      },
      inputDefaults: {
        timeout: 10,
        maxDigits: 1,
        maxAttempts: 3,
        required: true,
        onMissingInput: function(call, flow) {
          flow.say("Sorry, I didn't get that");
          return flow.goto(call.action, call.attempt + 1);
        },
        onInvalidInput: function(call, flow) {
          flow.say("That was not a valid entry");
          return flow.goto(call.action, call.attempt + 1);
        },
        onMaxInvalidInput: function(call, flow) {
          flow.say("Due to lack of input, this call will now be disconnected. Goodbye");
          return flow.hangup();
        }
      },
      recordDefaults: {
        timeout: 10,
        maxAttempts: 3,
        required: true,
        onMissingRecording: function(call, flow) {
          flow.say("Sorry, I didn't get that. Please try again louder");
          return flow.goto(call.action, call.attempt + 1);
        },
        onMaxMissingRecordings: function(call, flow) {
          flow.say("Due to lack of voice input, this call will now be disconnected. Goodbye");
          return flow.hangup();
        }
      }
    };
    app.router = express.Router();
    app.createCall = function(id, req) {
      var call;
      console.log("New Call " + id);
      call = {
        id: id,
        from: get(req, 'From'),
        to: get(req, 'To'),
        direction: get(req, 'Direction'),
        time_started: new Date(),
        caller_id: get(req, 'CallerName'),
        acceptableInputs: [],
        fromCity: get(req, 'FromCity'),
        fromState: get(req, 'FromState'),
        fromZip: get(req, 'FromZip'),
        fromCountry: get(req, 'FromCountry'),
        toCity: get(req, 'ToCity'),
        toState: get(req, 'ToState'),
        toZip: get(req, 'ToZip'),
        toCountry: get(req, 'ToCountry'),
        answeredBy: get(req, 'AnsweredBy')
      };
      call.flow = tFlow(call);
      call.app = app;
      app.calls[id] = call;
      return call;
    };
    app.updateCall = function(call, req) {
      var scriptName;
      call.attempt = get(req, 'attempt');
      if (call.attempt == null) {
        call.attempt = 0;
      }
      call.attempt = parseInt(call.attempt);
      call.action = get(req, 'action');
      call.recordingURL = get(req, 'RecordingUrl');
      call.recordingID = get(req, 'RecordingSid');
      call.recordingDuration = get(req, 'RecordingDuration');
      call.digits = get(req, 'Digits');
      call.status = get(req, 'CallStatus');
      call.duration = get(req, 'CallDuration');
      call.outerBody = void 0;
      call.body = [];
      call.response = {
        Response: call.body
      };
      scriptName = get(req, 'script');
      return app.setScript(call, scriptName);
    };
    app.setScript = function(call, scriptName) {
      var err, error1, scriptPath;
      if (scriptName) {
        call.scriptName = scriptName;
      }
      if (call.scriptName === void 0) {
        call.scriptName = app.defaultScript;
      }
      scriptPath = app.scripts[call.scriptName];
      if (call.script === void 0 || app.testMode === true) {
        try {
          delete require.cache[require.resolve(scriptPath)];
        } catch (error1) {
          err = error1;
          console.log("Unable to delete require cache: " + err);
        }
        return call.script = require(scriptPath)(call, call.flow);
      }
    };
    app.loadPrompts = function(call) {
      return di.model.Prompts.findAll();
    };
    app.router.use("/", function(req, res) {
      var key, ref, value;
      if (app.defaultScript === void 0) {
        ref = app.scripts;
        for (key in ref) {
          value = ref[key];
          app.defaultScript = key;
          break;
        }
      }
      return Promise.resolve().then(function() {
        var call, callId;
        callId = req.body.CallSid;
        if (callId === void 0 && app.testMode === true) {
          if (callId == null) {
            callId = 0;
          }
        }
        if (callId === void 0) {
          throw "Invalid request";
        }
        call = app.calls[callId];
        if (call === void 0) {
          return app.createCall(callId, req);
        } else {
          return call;
        }
      }).then(function(call) {
        app.updateCall(call, req);
        return Promise.resolve().then(function() {
          if (call.flow.prompts === void 0 || app.testMode === true) {
            return Promise.resolve(app.loadPrompts(call)).then(function(prompts) {
              call.flow.prompts = {};
              return prompts.forEach(function(p) {
                return call.flow.prompts[p.text] = p;
              });
            });
          }
        }).then(function() {
          var ref1, ref2;
          if ((ref1 = req.query) != null ? ref1.onGather : void 0) {
            if (call.attempt > call.maxAttempts) {
              return call.onMaxInvalidInput(call, call.flow);
            } else {
              return call.flow.onResolveInput();
            }
          } else if ((ref2 = req.query) != null ? ref2.onRecord : void 0) {
            if (call.attempt > call.maxAttempts) {
              return call.onMaxMissingRecordings(call, call.flow);
            } else {
              return call.onResolveRecord();
            }
          } else {
            return call.script[call.action]();
          }
        })["catch"](function(err) {
          return app.onError(call, err);
        }).then(function() {
          if (app.log) {
            return app.log(call);
          }
        }).then(function() {
          var xres;
          xres = xml(call.response, {
            declaration: {
              encoding: 'UTF-8'
            }
          });
          res.set('Content-Type', 'text/xml');
          return res.send(xres);
        });
      });
    });
    return app;
  };

}).call(this);
